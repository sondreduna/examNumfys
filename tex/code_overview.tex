The source code for this project is structured into separate files for each sub-problem, i.e. \lstinline|prob_2A.py|, \lstinline|prob_2B.py| etc. Additionally, there is a file for plotting for each sub-problem. I have also included a file called \lstinline|utils.py| which contains some useful utility functions used throughout the exercises. For problem $2$A I have used the same ODE-solver as the one I made for exercise $2$. This can be found in \lstinline|ode.py|.

\subsection{Remarks on performance}

In many parts I gained a lot of performance by compiling the code with \lstinline|numba|, as usual.

My solution for solving the commuter model worked reasonably well in problem 2D, but when I reached problem 2E I found it to be \textit{very} memory consuming, as I store the number of people in each state for each group of people for each time step, that is an array of size
$$
	\#\text{time steps}\times\#\text{towns} \times\#\text{towns} \times 5.
$$ 
For the population structure in problem 2Eb this yields an array of approximately $4.7$ GiB when using $1000$ time steps. To avoid these memory issues I modify the solver to only save the number of people in each state for each group of people for the current and previous time step. This allows for running lower time steps, and importantly, it makes it possible to run the $10$ simulations in parallel. 

From profiling the code used in problem 2Eb I found that the most time consuming part was the stepping function which draws random numbers for each entry in the table. I initially tried to draw these random numbers in a vectorised fashion, but found I it to become exceedingly confusing to understand what the functions were doing in each step, and I got some issues with people disappearing from the population. However, I found major improvements by modifying the line where I step forward using the function \lstinline|SEIIaR_commuter_step()| to the following:
\begin{lstlisting}[language=Python]
if M[l,k] == 0:
    X[l,k,:] = X_[l,k,:]
else:
    X[l,k,:] = SEIIaR_commuter_step(X_[l,k,:],Pse[k],Pei,Peia,Pir,Piar)
\end{lstlisting} 

This is particularly useful in this case, as there are \textit{many} entries in the matrix where there are no people at all. Testing with and without this change, with a step length of $0.1$ yields the following results:
\begin{lstlisting}
# Solution without skipping empty entries
dt = 0.1
%time T, I = SEIIaR_commuter_greedy(M,X_0,tN,dt)
\end{lstlisting}
\texttt{\small CPU times: user 1min 17s, sys: 230 ms, total: 1min 17s
Wall time: 1min 17s}
\begin{lstlisting}
# Solution _with_ skipping empty entries
dt = 0.1
%time T, I = SEIIaR_commuter_greedy(M,X_0,tN,dt)
\end{lstlisting}
\texttt{\small CPU times: user 22.4 s, sys: 58.5 ms, total: 22.5 s
Wall time: 22.4 s}